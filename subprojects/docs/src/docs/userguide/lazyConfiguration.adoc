// Copyright 2017 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[lazy_configuration]]
== Lazy Configuration

As a build grows in complexity, knowing when and where a particular value is configured can become difficult to reason about. Gradle provides several ways to manage this complexity with lazy configuration.

[[sec:lazy_properties]]
=== Lazy properties

[NOTE]
====

The provider API is currently <<feature_lifecycle,incubating>>. Please be aware that the DSL and other configuration may change in later Gradle versions.

====

First, Gradle provides lazy properties, which delay the calculation of a property’s value until it’s absolutely required. This provides two main benefits to build script and plugin authors:

1. Build authors can wire together Gradle models without worrying when a particular property’s value will be known.
2. Build authors can avoid resource intensive work during the configuration phase, which can have a direct impact on maximum build performance.

Gradle represents lazy properties with two interfaces:

* api:org.gradle.api.provider.Provider[] are properties that can only be queried and cannot be changed.
** Properties with these types are read-only.
** The method api:org.gradle.api.provider.Provider#get()[] returns the current value of the property.
** A Provider can be created by the factory method api:org.gradle.api.Project#provider(java.util.concurrent.Callable)[].
* api:org.gradle.api.provider.Property[] are properties that can be queried and overwritten.
** Properties with these types are configurable.
** Property implements the Provider interface.
** The method api:org.gradle.api.provider.Property#set(T)[] provides a value for the property, overwriting whatever value may have been present.
** A Property can be created by the factory method api:org.gradle.api.model.ObjectFactory#property(java.lang.Class)[].

Neither of these types or their subtypes are intended to be implemented by a build script or plugin author.  Gradle provides several factory methods to create instances of these types. See the <<lazy_configuration_reference,Quick Reference>> for all of the types and factories available.

Lazy properties are intended to be passed around and only evaluated when required (usually, during the execution phase). For more information about the Gradle build phases, please see <<sec:build_phases>>.

The following demonstrates a task with a read-only property and a configurable property:

++++
<sample id="usePropertyAndProvider" dir="providers/propertyAndProvider" title="Using read-only and configurable property">
    <sourcefile file="build.gradle"/>
</sample>
++++

The `Greeting` task has a `Property<String>` for the mutable part of the message and a `Provider` for the modified, read-only, message.

[[sec:why_new_types]]
=== Why new types?
The Provider API is a public implementation of a feature Gradle has had internally for a long time--convention mapping. The new types are faster, more understandable and better instrumented than the internal convention mapping mechanism. It also allows for more consistent build logic since it allows a plugin or task to express what it wants without worrying about when.

[[sec: creating_property_provider]]
===Creating a Property or Provider

Since provider types are not intended for implementation by build script or plugin authors, how do you create new one? Gradle provide various factory APIs to create new instance of both api:org.gradle.api.provider.Provider[] and api:org.gradle.api.provider.Property[]:

- api:org.gradle.api.model.ObjectFactory#property(java.lang.Class)[] instantiates a new api:org.gradle.api.provider.Property[]. An instance of the ObjectFactory can be reference from the api:org.gradle.api.Project#getObjects()[] or by injecting ObjectFactory through a constructor or method.
- api:org.gradle.api.provider.ProviderFactory#provider(java.util.concurrent.Callable)[] instantiates a new api:org.gradle.api.provider.Provider[]. A handy method is available at api:org.gradle.api.Project#provider(java.util.concurrent.Callable)[]. If a api:org.gradle.api.Project[] instance isn’t available, you can inject api:org.gradle.api.providers.ProviderFactory through a constructor or method.

[NOTE]
====

The api:org.gradle.api.Project[] does not provide a specific method signature for creating a provider by passing in a `groovy.lang.Closure` as parameter. When writing a plugin implementation with Groovy, you can use the method signature accepting a `java.util.concurrent.Callable` parameter. Groovy's http://docs.groovy-lang.org/next/html/documentation/core-semantics.html#_assigning_a_closure_to_a_sam_type[Closure to type coercion] will take of the rest.

====

[[sec:working_with_files_in_lazy_properties]]
=== Working with files and Providers

In <<working_with_files>>, we introduced four collection types for File-like objects:

.Collection of files recap
[width="100%",cols="2,2", options="header"]
|=========================================================
|Read-only Type
|Configurable Type

|api:org.gradle.api.file.FileCollection[]
|api:org.gradle.api.file.ConfigurableFileCollection[]

|api:org.gradle.api.file.FileTree[]
|api:org.gradle.api.file.ConfigurableFileTree[]

|=========================================================

All of these types are also considered Provider types.

In this section, we are going to introduce more strongly typed models for a api:org.gradle.api.file.FileSystemLocation[]: api:org.gradle.api.file.Directory[] and api:org.gradle.api.file.RegularFile[]. These types shouldn't be confused with the standard Java File type as they tell Gradle to expect more specific values (a directory or a non-directory, regular file). Gradle provides two specialized api:org.gradle.api.provider.Property[] subtypes for dealing with these types: api:org.gradle.api.file.RegularFileProperty[] and api:org.gradle.api.file.DirectoryProperty[]. As with any api:org.gradle.api.provider.Property[], ObjectFactory[] has methods to create these: api:org.gradle.api.file.ProjectLayout#fileProperty()[] and api:org.gradle.api.file.ProjectLayout#directoryProperty()[].

A api:org.gradle.api.file.DirectoryProperty[] can also be used to create lazily evaluated Providers for `Directory` and `RegularFile` via api:org.gradle.api.file.DirectoryProperty#dir(java.lang.String)[] and api:org.gradle.api.file.DirectoryProperty#file(java.lang.String)[] respectively. These methods create paths that are relative to location set for the original api:org.gradle.api.file.DirectoryProperty[].

++++
<sample id="workingWithFiles" dir="providers/fileAndDirectoryProperty" title="Using file and directory property">
    <sourcefile file="build.gradle"/>
</sample>
++++

The previous example shows how providers are used inside an extension. Lazy values for the well known build directory (api:org.gradle.api.Project#getBuildDir()[]) and project directory (api:org.gradle.api.Project#getProjectDir()[]) can be accessed through api:org.gradle.api.Project#getLayout()[] with api:org.gradle.api.file.ProjectLayout#getBuildDirectory()[] and api:org.gradle.api.file.ProjectLayout#getProjectDirectory()[] respectively. Note that Gradle inject setter methods for each property getter methods. These setter methods allow you to configure the property value using the assign operator for convenience.

[[sec:working_with_task_dependencies_in_lazy_properties]]
=== Working with task dependencies and Providers

Often you will have several tasks that depend on each other. This usually means that one task processes outputs of another task as an input. For these outputs and inputs, we need to know their locations on the file system and appropriate configure each task to know where to look. This can be cumbersome if any of these values are configurable by a user or contributed by multiple plugins.

To make this easier, Gradle offers convenient APIs for defining files or folders as task inputs and outputs in a descriptive way. As an example consider the following plugin with compile, package and install tasks which are wired via inputs and outputs:

++++
<sample id="implicitTaskDependency" dir="providers/implicitTaskDependency" title="Implicit task dependency">
    <sourcefile file="build.gradle"/>
</sample>
++++

In the example above, the task output and input are connected before any concrete files system location is defined. This is possible because file locations are described by using providers that are created via api:org.gradle.api.DefaultTask#newOutputFile()[] and api:org.gradle.api.DefaultTask#newInputFile()[]. The providers are a complete replacement for setters and overloads. This way the files are only actually resolved when they are needed during execution. The setters can be called at any time before the task is executed and the change will automatically affect all related input and output properties.

Another thing to note is the absence of api:org.gradle.api.Task#dependsOn(java.lang.Object...)[] invocation. Properties created via `newOutputFile()` and `newOutputDirectory()` bring some knowledge about which task is generating them and thus using them as task input will implicitly link tasks together.


[[sec:lazy_configuration_faqs]]
=== FAQs
* Should I expose the api:org.gradle.api.provider.Property[] directly?
** Yes. For configurable properties (subtypes of api:org.gradle.api.provider.Property[]), there should be a single getter that returns the api:org.gradle.api.provider.Property[]. For non-configurable properties, there should be a single getter that returns a api:org.gradle.api.provider.Provider[].
* Should I encapsulate the api:org.gradle.api.provider.Property[] behind setter/getter?
** No. The api:org.gradle.api.provider.Property[] and api:org.gradle.api.provider.Provider[] types have all of the overloads you need to query or configure a value.
* How can I simplify calls like `obj.getProperty().get()` and `obj.getProperty().set(T)`?
** You don’t. This makes it very explicit when a property's value is resolved. Generally, you only call api:org.gradle.api.provider.Provider#get()[] in a task action. In most cases, you pass around lazy representations instead.
* How will the Provider API affect new and existing Gradle tasks?
** The Provider API will be used for new properties going forward. The Groovy Gradle DSL adds convenience methods to make the use of Providers mostly transparent in build scripts.
** Existing tasks will have their existing "raw" properties replaced by Providers as needed and in a backwards compatible way.
** New tasks will be designed with the Provider API.
* How should I migrate my plugin to use providers?
** If it's a new property, expose it as a api:org.gradle.api.provider.Property[] or api:org.gradle.api.provider.Provider[] using a single getter.
** If it's incubating, change it to use a api:org.gradle.api.provider.Property[] or api:org.gradle.api.provider.Provider[] using a single getter.
** If it's a stable property, add a new api:org.gradle.api.provider.Property[] or api:org.gradle.api.provider.Provider[] and deprecate the old one. You should wire the old getter/setters into the new property as appropriate.


[[sec:lazy_configuration_roadmap]]
=== Future development

The provider API is <<feature_lifecycle,incubating>>. Please open issues https://github.com/gradle/gradle/issues/new[gradle/gradle] to report bugs or to submit use cases for new features.

[[sec:lazy_configuration_reference]]
=== Provider API Quick Reference

.Lazy properties summary
[width="100%",cols="3,^2,^2,10a",options="header"]
|=========================================================
|Description |Read-only |Configurable |Factory

|A file on disk (not to be confused with Java File API)
|api:org.gradle.api.provider.Provider[]<api:org.gradle.api.file.RegularFile[]>
|api:org.gradle.api.file.RegularFileProperty[]
|* api:org.gradle.api.file.ProjectLayout#fileProperty()[]
* api:org.gradle.api.file.Directory#file(java.lang.String)[]
* api:org.gradle.api.file.DirectoryProperty#file(java.lang.String)[]

|A file used as a task input/output
|api:org.gradle.api.provider.Provider[]<api:org.gradle.api.file.RegularFile[]>
|api:org.gradle.api.file.RegularFileProperty[]
|* api:org.gradle.api.DefaultTask#newInputFile()[]
* api:org.gradle.api.DefaultTask#newOutputFile()[]

|A directory on disk
|api:org.gradle.api.provider.Provider[]<api:org.gradle.api.file.Directory[]>
|api:org.gradle.api.file.DirectoryProperty[]
|* api:org.gradle.api.file.ProjectLayout#directoryProperty()[]
* api:org.gradle.api.file.Directory#dir(java.lang.String)[]
* api:org.gradle.api.file.DirectoryProperty#dir(java.lang.String)[]

|A directory used as a task input/output
|api:org.gradle.api.provider.Provider[]<api:org.gradle.api.file.Directory[]>
|api:org.gradle.api.file.DirectoryProperty[]
|* api:org.gradle.api.DefaultTask#newInputDirectory()[]
* api:org.gradle.api.DefaultTask#newOutputDirectory()[]

|Collection of files
|api:org.gradle.api.file.FileCollection[]
|api:org.gradle.api.file.ConfigurableFileCollection[]
|* api:org.gradle.api.Project#files(java.lang.Object...)[]

|Hierarchy of files
|api:org.gradle.api.file.FileTree[]
|api:org.gradle.api.file.ConfigurableFileTree[]
|* api:org.gradle.api.Project#fileTree(java.lang.Object)[]

|List of any type
|api:org.gradle.api.provider.Provider[]<List<T>>
|api:org.gradle.api.provider.ListProperty[]
|* api:org.gradle.api.model.ObjectFactory#listProperty(java.lang.Class)[]

|Any other type
|api:org.gradle.api.provider.Provider[]<T>
|api:org.gradle.api.provider.Property[]<T>
| * api:org.gradle.api.Project#provider(java.util.concurrent.Callable)[]
* api:org.gradle.api.model.ObjectFactory#property(java.lang.Class)[]

|=========================================================
